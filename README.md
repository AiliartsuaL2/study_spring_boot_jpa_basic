# study_spring_boot_jpa_basic
인프런 김영한 '자바 ORM 표준 JPA 프로그래밍 기본편' 라이브 코딩 및 필기

자바 ORM 표준 JPA 프로그래밍

SQL 중심적인 개발의 문제점
- 애플리케이션의 개발은 보통 객체지향의 언어로 개발 진행, 데이터베이스는 관계형 DB사용
    - CRUD를 계속 반복한다… >> 자바 객체를 SQL로, SQL을 자바 객체로 받아야됨
- 패러다임의 불일치 : 객체와 관계형 베이스의 차이
    - 객체의 상속은 DB의 슈퍼타입 서브타입 관계로 생각 해볼 수 있다.
        - 데이터 삽입시 하위타입의 객체를 넣어주려면 쿼리를 슈퍼타입과 서브타입 두개에 다 넣어줘야함,,
        -  데이터 조회시 조인해서 객체로 매핑하고 매핑하고.. 케이스마다 조인쿼리를 다 만들어야함,, 매우 복잡
    - 연관관계
        - 객체는 참조를 사용하고 테이블은 외래 키를 사용한다. >> 객체를 테이블에 맞추어 저장한다.
    - 객체 그래프 탐색
        - 객체는 자유롭게 객체 그래프를 탐색 할 수 있어야 하지만, 처음 실행하는 SQL에 따라 달라진다 >> 엔티티에 대한 신뢰도가 떨어짐
        - 계층형 아키텍쳐(컨트롤러 서비스 레포지토리)는 다른 계층에 대한 신뢰가 있어야 사용 할 수 있음..
    - 비교하기
        - SQL에서 꺼내온 객체 2개를 비교하면 두 객체는 서로 다름
        - 컬렉션에서 꺼내온 객체 2개를 비교하면 두 객체는 서로 같음,,
- 객체답게 모델링 할 수록 매핑 작업만 늘어남…. 
- >> 자바 컬렉션에 저장하듯 데이터를 저장하는 방법.. JPA!

JPA란 : JavaPersistenceAPI,, 자바 진영의 ORM 기술 표준
- ORM : Object-Relational(관계형DB) Mapping
    - 객체는 객체대로 설계하고 , 관계형 DB는 관계형 DB대로 설계.
    - ORM 프레임워크가 중간에서 매핑하여 패러다임의 불일치등을 해결해줌
    - 대중적인 언어에는 대부분 ORM 기술이 존재
- 애플리케이션과 JDBC 사이에서 동작함.
- JPA의 동작
    - 저장 : JPA에게 저장 호출시 JPA가 Entity 분석하여 InsertSQL 생성, JDBC API 사용하여 패러다임 불일치를 해결함
    - 조회 : JPA에게 조회 호출시 : select쿼리 만들어서 JDBC API생성, ResultSet 매핑, 패러다임 불일치(상속이나 문제점들) 해결
- EJB 중 엔티티 빈이라는 자바 표준 ORM이 있었는데, 실용성이 떨어져서 어떤 개발자가 하이버 네이트라는 오픈소스를 만듬 > > Java에서 영입해서 하이버네이트 개발자를 데려와서 하이버네이트랑 거의 똑같이 해서 만듬 
    - 오픈소스로부터 시작했기 때문에 실용적이다
    - JPA는 인터페이스의 모음, 대표적인 구현체 3가지
        - 구현체 1. 하이버네이트 80~90% 이상
        - 구현제 2. EclipseLink
        - 구현체 3. 
    - JPA를 사용해야하는 이유
        - SQL 중심적인 개발에서 객체 중심으로 개발 >> 패러다임 불일치 해결, 생산성 ,유지보수 향상,,
        - 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장
        - 성능 최적화 기능 지원
            - 중간에 매개가 되는 기술이 추가가되면 캐싱(이미 조회했던 것은 매개에서 보내줌), 버퍼라이팅(모아서 한번에 보내줌)이 가능, 
            - 1차 캐시와 동일성 보장 : 같은 트랜잭션 안에서는 같은 엔티티 반환 > 약간의 조회 성능 향상
            - 트랜잭션을 지원하는 쓰기 지연 (버퍼 라이팅)
                - Insert : 트랜잭션을 커밋 할 때까지 Insert SQL을 모으고 한 번에 SQL 전송 > 네트워크 통신 비용 감소
                - Update ,, 있음
            - 지연 로딩과 즉시 로딩
                - 지연 로딩(Lazy) : 객체가 실제 사용 될 때 로딩
                - 즉시 로딩(Eager) : Join SQL로 한 번에 연관된 객체까지 미리 조회
- 하이버네이트 설정
    - dialect : JPA는 특정 데이터베이스에 종속 X,,
        - 각각의 DB가 제공하는 SQL 문법과 함수는 조금씩 다름, (VARCHAR, VARCHAR2 등)
- JPA 구동 방식 : Persistence가 설정 정보(/META-INF/persistence.xml의 unitName)를 조회하여 EntityManagerFactory 클래스를 생성하고, EMF 클래스가 EntityManager를 생성
JPA 생성 
- DB 테이블에 맞는 엔티티 생성
    - 도메인을 만들고, 클래스레벨에 @Entity를 붙여줌.
- 엔티티 매니저 팩토리는 로딩 시점에 딱 1개만 만들어야함
    - 웹서버 올라갈 시점에 DB당 1개만 생성!
- 실제 DB에 저장하는 트랜잭션(DB커넥션 하나를 얻어서 저장하고 종료시키는) 단위 하나당 엔티티 매니저 하나를 꼭 생성해줘야함 
    - 엔티티 매니저는 트랜잭션 사이클 내에서 작동이 되기 때문에 트랜잭션을 실행시키고 꺼주는 프로세스가 필요함
    - 엔티티 매니저는 한 번만 사용해야하고 쓰레드간 공유를 하면 절대 안됨,, 사용하고 버려야함
    - JPA의 모든 데이터 변경은 트랜잭션 안에서 실행. (조회는 트랜잭션 없어도 괜찮다.)
- Update : JPA로 조회를 하게되면 JPA가 관리를하고, 트랜잭션이 끝나는 시점에 값을 비교 후 변경되었으면 자동으로 Update 쿼리를 날림 >> java에서 collection 처럼 다룸  
- Select : 조건 검색을 위해선 JPQL을 통해서 조회
- JPQL : JPA에서 코드를 짤 때 테이블을 대상으로 쿼리를 짜지않고, 엔티티를 기준으로 쿼리를 짬 (from Member << 테이블이 아닌 객체)  
    - ANSI에서 제공하는건 다 가능,
    - 모든 DB 데이터를 객체로 변환하는건 불가능,, 결국엔 검색조건의 SQL이 필요 (JPQL의 필요성)
    - SQL을 추상화시킨 객체 지향 쿼리 언어
JPA는  내부적으로 리플렉션을 쓰기 때문에 동적으로 객체를 생성함 >>도메인의 기본생성자가 필요함

JPA에서 가장 중요한 2가지
- 객체와 관계형 DB 매핑하기
- 영속성 컨텍스트: 엔티티를 영구 저장하는 환경
    - 엔티티매니저 팩토리가 엔티티 매니저를 생성해서 요청을 수행함, 엔티티 매니저는 DB 커넥션풀을 잡고 실행
    - 논리적인 개념이고 눈에 보이지 않는다. 엔티티 매니저를 통해 영속성 컨텍스트에 접근함.
    - 엔티티의 생명주기
        - 비영속 (new, transient)
            - 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
            - 객체를 생성한 상태(JPA와 관계 없는 상태)
        - 영속 (managed)
            - 영속성 컨텍스트에 관리되는 상태
            - 영속성 콘텍스트(엔티티 매니저)안에 객체가 들어가있는 경우 (persist 쓴 상태)
        - 준영속 (detached)
            - 영속성 컨텍스트에 저장되었다가 분리된 상태
        - 삭제
            - 삭제된 상태
    - 영속성 컨텍스트의 이점 ,, 어플리케이션과 DB사이의 중간 매개체가 있어서 얻는 이점,
        - 1차 캐시
            - 맵으로 되어있고, 키가 @Id로 지정한 컬럼 , 값은 등록한 Entity
            - DB가 아닌 1차 캐시를 먼저 확인하고 해당 캐시에 해당하는 값을 준다. 없으면 DB에서 가져와서 1차캐시에 저장하고 반환해줌
            - DB 트랜잭션 안에서만 작용하기때문에 성능에 큰 영향을 주진 않음
        - 영속 엔티티의 동일성 보장
            - 영속성에서 조회해온 id값이 같은 엔티티의 경우 인스턴스가 동일함,(==)
        - 트랜잭션을 지원하는 쓰기 지연
            - 쿼리를 데이터 베이스에 보내지않고 있다가 commit하는 순간 트랜잭션을 처리함 (flush)
            - 쓰기지연 SQL 저장소에 저장해 뒀다가 한 번에 처리함
            - hibernate.jdbc.batch_size 를 설정하면 설정한 값만큼 쿼리를 모아서 한 번에 DB에 날림,, 버퍼링처럼
        - 엔티티 수정(변경감지, dirty Checking)
            - 영속상태에 들어간 이후, 값을 변경하고서 persist를 안해줘도 자바 컬렉션처럼 자동으로 업데이트 쿼리를 날림
            - JPA는 값을 최초에 읽어온 시점에 스냅샷으로 저장해두고 commit 시점에 엔티티와 스냅샷을 비교한다. 값이 다를경우 update 쿼리를 날림.

    
 
